import pathlib
import os
import numpy as np
import cv2 as cv
import tensorflow as tf

def otsu_canny(image, lowrate=0.1):
    """
    Implements "Otsu Canny" algorithm for image

    Args:
        image (np.array): Image for which we apply "Otsu Canny" algorithm
        lowrate (float): Hyperparameter for Canny algorithm for lower threshold
    Returns: (np.array)
        Edge map generated by "Otsu Canny" algorithm
    """
    if len(image.shape) > 2:
        image = cv.cvtColor(image, cv.COLOR_RGB2GRAY)

    # Otsu's thresholding
    ret, _ = cv.threshold(image, thresh=0, maxval=255, type=(cv.THRESH_BINARY + cv.THRESH_OTSU))
    edged = cv.Canny(image, threshold1=(ret * lowrate), threshold2=ret)

    # return the edged image
    return edged

def create_mask(image_size, x= 224 // 2 - 224 // 8 , y= 224 // 2 - 224 // 8):
    """
    Create mask which superimposed
    Args:
        image_size (int): Size of image
        x (int): X coordinate for center of image
        y (int): Y coordinate for center of image

    Returns: (np.array)
        Mask image and coordinates for identifying location of mask
    """
#     mask_width, mask_height = np.random.randint(image_size // 8, image_size // 3, size = 2)
    mask_width, mask_height = image_size // 4, image_size // 4
    mask = np.ones((image_size, image_size), dtype = np.uint8)
    mask_x = x if x is not None else np.random.randint(0, image_size - mask_width)
    mask_y = y if y is not None else np.random.randint(0, image_size - mask_height)
    mask[mask_y:mask_y + mask_height, mask_x:mask_x + mask_width] = 0
    return mask, mask_x, mask_y, mask_height, mask_width

def read_labels(path, image_size = 224, sigma = 0.33):
    """
    Main function for preprocessing image. Read image, Create mask, Impose mask, Create Edge map.

    Args:
        path (str): Path to image
        image_size (int): Size of image we want recover
        sigma (float): Deprecated parameter will be removed in next version. Analogue lowrate in otsu_canny

    Returns: tf.Tensor
         Concatenation of model input and real_image
    """
    image = tf.io.read_file(path)
    image = tf.image.decode_jpeg(image, channels = 3)

    temp = np.array(image)
    temp = cv.resize(temp, (image_size, image_size), interpolation = cv.INTER_AREA)
    image = tf.cast(tf.convert_to_tensor(temp), tf.float32)

    mask, mask_x, mask_y, mask_height, mask_width = create_mask(image_size)

#     mask = np.ones((image_size, image_size), dtype = np.uint8)
#     cv.rectangle(mask, (image_size // 2 - image_size // 8, image_size // 2 - image_size // 8) , (image_size // 2 + image_size // 8, image_size // 2 + image_size // 8), 0, -1)

#     v = np.median(temp)
#     lower = min(0, v * (1 - sigma))
#     upper = max(255, v * (1 + sigma))


#     edge_map = tf.expand_dims(tf.convert_to_tensor(cv.Canny(temp, lower, upper)), axis = 2)
    mask_image = tf.cast(tf.expand_dims(tf.convert_to_tensor(mask), axis = 2), tf.float32)

    temp[mask_y : mask_y + mask_height, mask_x : mask_x + mask_width] = np.random.normal(127.5, scale = 5, size = (mask_height, mask_width, 3))
    edge_map = tf.cast(tf.expand_dims(tf.convert_to_tensor(otsu_canny(temp)), axis = 2), tf.float32)
    train_image = tf.cast(tf.convert_to_tensor(temp), tf.float32)


    train_image -= 127.5
    train_image /= 127.5
    edge_map -= 127.5
    edge_map /= 127.5


    image_edge_mask = tf.concat([train_image, edge_map, mask_image], axis = 2)

    image -= 127.5
    image /= 127.5

    return tf.concat([image_edge_mask, image], axis = 2)


# In[70]:


def preprocess_image(path):
    """
    Neccessary shell on read_labels for using with tf

    Args:
        path (str): Path to image

    Returns: tuple
        Tuple with model input and true_image
    """
    image = tf.py_function(read_labels, [path], tf.float32)
    return (image[:,:, :5], image[:, :, 5:])


# In[71]:


def get_dataset(path):
    """
    Create dataset from folder with images
    
    Args:
        path (str): Path to directory where is located images

    Returns: tf.Dataset, list of strings
        tf.Dataset with paths to images and list with paths to images
    """
    folders = [x[0] for x in os.walk(pathlib.Path(path))][1:]
    all_image_paths = []

    for folder in folders:
        data_root = pathlib.Path(folder)
        appendix = list(data_root.glob('*'))
        appendix = [str(path) for path in appendix]
        for elem in appendix:
            all_image_paths.append(elem)

    path_ds = tf.data.Dataset.from_tensor_slices(all_image_paths)
    all_image_paths.sort()

    return path_ds, all_image_paths
